# CURSO: INTRODUCCI√ìN AL DESARROLLO DE NUEVAS PLATAFORMAS

## Docente
Ernesto Su√°rez

## Integrantes
* Sebasti√°n Arley Chirinos Negr√≥n
* Rodrigo Est√©fano Viza Cuti

---

# MediNotis: Prototipo de App Accesible

MediNotis es un prototipo de aplicaci√≥n para Android, construida con tecnolog√≠as modernas, dise√±ada para el registro de recordatorios de medicamentos. Su objetivo principal es demostrar un fuerte enfoque en la **accesibilidad (A11y)**, permitiendo a los usuarios (especialmente adultos mayores) ajustar din√°micamente la interfaz a sus necesidades visuales.



## üöÄ Caracter√≠sticas Principales

* **Formulario Simple:** Un formulario claro para registrar el nombre del medicamento, el d√≠a y la hora.
* **Slider de Accesibilidad:** Un control deslizante que permite al usuario escalar din√°micamente todo el tama√±o del texto de la UI (de 100% a 180%) para una mejor legibilidad.
* **Persistencia de Ajustes:** La app **recuerda** la configuraci√≥n de tama√±o de texto preferida por el usuario. Esta preferencia se guarda de forma persistente incluso si la aplicaci√≥n se cierra por completo.
* **UI Accesible:** Dise√±o con objetivos t√°ctiles grandes (botones y campos de texto), etiquetas claras fuera de los campos y un layout espaciado para evitar confusiones.

---

## üèõÔ∏è Arquitectura y Explicaci√≥n Detallada del C√≥digo

Este proyecto utiliza un stack moderno de Android basado en la arquitectura **MVVM (Model-View-ViewModel)** y un **flujo de datos unidireccional (UDF)**.

### 1. Stack Tecnol√≥gico

* **Lenguaje:** **Kotlin** 100%.
* **UI:** **Jetpack Compose** (Material 3) para una interfaz de usuario declarativa.
* **Arquitectura:** **MVVM (Model-View-ViewModel)**.
* **Persistencia:** **Jetpack DataStore (Preferences)** para guardar datos clave-valor de forma as√≠ncrona.
* **Asincron√≠a:** **Coroutines** y **Flow** de Kotlin para manejar el estado y las operaciones de fondo.

### 2. Estructura de Archivos y Clases (Detalle)

A continuaci√≥n, se detalla el rol de cada archivo y clase clave en el proyecto:

#### üìÑ `build.gradle.kts (M√≥dulo app)`

Es el archivo de configuraci√≥n de dependencias. Las adiciones clave fueron:

* `androidx.datastore:datastore-preferences:1.1.1`: Esta es la biblioteca de **DataStore**. Se eligi√≥ sobre `SharedPreferences` porque es **as√≠ncrona**, utiliza Coroutines y Flow, y no bloquea el Hilo Principal (UI Thread), previniendo errores "ANR" (Application Not Responding).
* `androidx.lifecycle:lifecycle-viewmodel-compose:2.8.0`: Permite integrar un `ViewModel` de forma nativa con Jetpack Compose, usando la funci√≥n `viewModel()`.
* `androidx.lifecycle:lifecycle-runtime-ktx:2.8.0`: Proporciona `collectAsState()` para convertir un `Flow` en un `State` que Compose pueda observar.

---

#### üìÑ `SettingsDataStore.kt` (Capa de Datos)

Esta clase es la **√∫nica fuente de verdad** para la configuraci√≥n guardada. A√≠sla toda la l√≥gica de lectura y escritura del resto de la app.

* `Context.dataStore`: Es una extensi√≥n que crea una **instancia √∫nica (singleton)** de DataStore llamada `"settings"`.
* `TEXT_SCALE_FACTOR_KEY`: Es una `floatPreferencesKey("text_scale_factor")`. Funciona como una llave segura para identificar nuestro dato. Evita errores de escritura (ej. "text_scale" vs "text_size").
* `val textScaleFactor: Flow<Float>`: Esta es la funci√≥n de **lectura**.
    * Expone un `Flow`, que es un flujo de datos as√≠ncrono. La UI se "suscribir√°" a este flujo.
    * `dataStore.data.map { ... }`: Se activa cada vez que los datos cambian.
    * `preferences[TEXT_SCALE_FACTOR_KEY] ?: 1.0f`: Intenta leer el valor `Float`. Si no existe (ej. la primera vez que se abre la app), devuelve un valor por defecto de `1.0f` (100%).
* `suspend fun saveTextScaleFactor(scaleFactor: Float)`: Esta es la funci√≥n de **escritura**.
    * Es una `suspend fun` (funci√≥n de suspensi√≥n) porque la escritura en disco es una operaci√≥n lenta que no debe bloquear la UI.
    * `dataStore.edit { ... }`: Inicia una transacci√≥n de escritura segura en un hilo de fondo.

---

#### üìÑ `SettingsViewModel.kt` (Capa de L√≥gica / ViewModel)

Esta clase act√∫a como el **"cerebro" de la UI** y el puente entre la Capa de Datos (DataStore) y la Capa de UI (Compose).

* `class SettingsViewModel(application: Application) : AndroidViewModel(application)`: Hereda de `AndroidViewModel` porque necesita el `Context` de la aplicaci√≥n para poder instanciar `SettingsDataStore`.
* `private val settingsDataStore = SettingsDataStore(application)`: Crea la instancia de nuestro gestor de datos.
* `val textScaleFactor: StateFlow<Float>`: Esta es la propiedad que la UI observar√°.
    * `settingsDataStore.textScaleFactor.stateIn(...)`: Convierte el `Flow` "fr√≠o" de DataStore en un `StateFlow` "caliente".
    * `viewModelScope`: Asegura que la corutina que escucha a DataStore viva solo mientras el ViewModel est√© vivo.
    * `SharingStarted.WhileSubscribed(5000)`: Optimizaci√≥n que le dice a DataStore que deje de escuchar si la app pasa a segundo plano por m√°s de 5 segundos.
* `fun updateTextScaleFactor(newScaleFactor: Float)`: Esta es la funci√≥n que la UI llama cuando el usuario mueve el slider.
    * `viewModelScope.launch { ... }`: Inicia una nueva corutina en el `viewModelScope` para realizar el trabajo de guardado.
    * `settingsDataStore.saveTextScaleFactor(newScaleFactor)`: Llama a la `suspend fun` de DataStore de forma segura, sin bloquear la UI.

---

#### üìÑ `MainActivity.kt` (Capa de UI / Vista)

Esta es la Actividad principal que aloja nuestra interfaz de Jetpack Compose.

* `private val settingsViewModel: SettingsViewModel by viewModels()`: Esta l√≠nea **inyecta** la instancia del ViewModel en la Actividad. `by viewModels()` se encarga de crear el ViewModel o de proveer el existente si la pantalla rota (sobrevive a cambios de configuraci√≥n).
* `val textScaleFactor by settingsViewModel.textScaleFactor.collectAsState()`: Esta es la l√≠nea clave que conecta la UI con el ViewModel.
    * `collectAsState()` se suscribe al `StateFlow` del ViewModel.
    * Cada vez que el valor en el `StateFlow` cambia, Compose **autom√°ticamente "recompone"** (redibuja) solo las partes de la UI que dependen de `textScaleFactor`.
* `PantallaRegistroMedicamentos(currentScaleFactor = textScaleFactor, ...)`: Aqu√≠ se aplica el **Flujo de Datos Unidireccional**:
    1.  El estado (`textScaleFactor`) fluye **hacia abajo** (de ViewModel a Composable).
    2.  Los eventos (`onScaleFactorChange`) fluyen **hacia arriba** (de Composable a ViewModel).

#### üìÑ `Composables` (Ej. `PantallaRegistroMedicamentos` y `CampoDeTextoAccesible`)

Estos son los bloques de construcci√≥n de la UI.

* `PantallaRegistroMedicamentos(currentScaleFactor: Float, onScaleFactorChange: (Float) -> Unit)`:
    * Este Composable es **"Stateless" (sin estado)**. No tiene su propia variable `textScaleFactor`; recibe el estado desde arriba. Esto lo hace m√°s predecible, reutilizable y f√°cil de probar.
    * Pasa el `currentScaleFactor` a todos los `Text` y `CampoDeTextoAccesible` para aplicar el escalado.
    * Contiene el `Slider` que, en su `onValueChange`, llama a la funci√≥n `onScaleFactorChange(newValue)`.
* `CampoDeTextoAccesible(...)`:
    * Es un Composable **reutilizable** creado para no repetir c√≥digo (principio DRY - Don't Repeat Yourself).
    * Define un est√°ndar de accesibilidad (etiqueta `Text` grande y visible fuera del `TextField`) que se aplica a todos los campos de texto del formulario.